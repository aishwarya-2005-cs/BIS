import random
import math

# ---------- Helper Functions ----------
# Distance between two cities
def distance(city1, city2):
    return math.sqrt((city1[0] - city2[0])**2 + (city1[1] - city2[1])**2)

# Total distance of a path
def path_length(path, cities):
    return sum(distance(cities[path[i]], cities[path[(i+1) % len(path)]]) 
               for i in range(len(path)))

# ---------- GA Operators ----------
# Create initial population
def create_population(pop_size, num_cities):
    population = []
    for _ in range(pop_size):
        path = list(range(num_cities))
        random.shuffle(path)
        population.append(path)
    return population

# Evaluate fitness (shorter path = higher fitness)
def evaluate_population(population, cities):
    return [1 / path_length(path, cities) for path in population]

# Selection (tournament selection)
def selection(population, fitnesses):
    tournament_size = 3
    selected = random.sample(list(zip(population, fitnesses)), tournament_size)
    selected.sort(key=lambda x: x[1], reverse=True)
    return selected[0][0]

# Crossover (Order Crossover - OX)
def crossover(parent1, parent2):
    start, end = sorted(random.sample(range(len(parent1)), 2))
    child = [None] * len(parent1)
    child[start:end] = parent1[start:end]
    pointer = end
    for city in parent2:
        if city not in child:
            if pointer >= len(parent1):
                pointer = 0
            child[pointer] = city
            pointer += 1
    return child

# Mutation (swap mutation)
def mutate(path, mutation_rate):
    for i in range(len(path)):
        if random.random() < mutation_rate:
            j = random.randint(0, len(path)-1)
            path[i], path[j] = path[j], path[i]
    return path

# ---------- Genetic Algorithm ----------
def genetic_algorithm_tsp(cities, pop_size=100, generations=500, crossover_rate=0.9, mutation_rate=0.02):
    population = create_population(pop_size, len(cities))
    best_path = None
    best_distance = float("inf")
    
    for gen in range(generations):
        fitnesses = evaluate_population(population, cities)
        
        # Track best solution
        for path in population:
            dist = path_length(path, cities)
            if dist < best_distance:
                best_distance = dist
                best_path = path[:]
        
        new_population = []
        while len(new_population) < pop_size:
            parent1 = selection(population, fitnesses)
            parent2 = selection(population, fitnesses)
            
            if random.random() < crossover_rate:
                child = crossover(parent1, parent2)
            else:
                child = parent1[:]
            
            child = mutate(child, mutation_rate)
            new_population.append(child)
        
        population = new_population
    
    return best_path, best_distance

# ---------- Run Example ----------
if __name__ == "__main__":
    # Example: 8 cities (x, y coordinates)
    cities = [(random.randint(0, 100), random.randint(0, 100)) for _ in range(8)]
    
    best_path, best_dist = genetic_algorithm_tsp(cities)
    print("Best Path:", best_path)
    print("Best Distance:", best_dist)
