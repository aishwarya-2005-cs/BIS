import random
from math import sin, gamma, pi

X = [
    [5.1, 3.5, 1.4, 0.2],
    [4.9, 3.0, 1.4, 0.2],
    [6.2, 3.4, 5.4, 2.3],
    [5.9, 3.0, 5.1, 1.8],
    [5.5, 2.3, 4.0, 1.3],
    [6.5, 3.0, 5.8, 2.2]
]
y = [0, 0, 2, 2, 1, 2]


X_train = X[:4]
y_train = y[:4]
X_test = X[4:]
y_test = y[4:]

def knn_predict(X_train, y_train, X_test, k=3):
    y_pred = []
    for xt in X_test:
        distances = []
        for i, xtr in enumerate(X_train):
            d = sum((a - b) ** 2 for a, b in zip(xt, xtr)) ** 0.5
            distances.append((d, y_train[i]))
        distances.sort()
        top_k = [label for _, label in distances[:k]]
        pred = max(set(top_k), key=top_k.count)
        y_pred.append(pred)
    return y_pred

def accuracy_score(y_true, y_pred):
    correct = sum(1 for a, b in zip(y_true, y_pred) if a == b)
    return correct / len(y_true)


def feature_fitness(solution):
    selected = [i for i, v in enumerate(solution) if v > 0.5]
    if not selected:
        return 1e6
    X_train_sel = [[x[i] for i in selected] for x in X_train]
    X_test_sel = [[x[i] for i in selected] for x in X_test]
    y_pred = knn_predict(X_train_sel, y_train, X_test_sel)
    acc = accuracy_score(y_test, y_pred)
    feature_ratio = len(selected) / len(solution)
    alpha, beta = 0.9, 0.1
    return alpha * (1 - acc) + beta * feature_ratio

def levy_flight(Lambda, size):
    step = [random.gauss(0, 1) for _ in range(size)]
    return step


def cuckoo_search_fs(d=4, n=10, max_iter=10, pa=0.25):
    nests = [[random.random() for _ in range(d)] for _ in range(n)]
    fitness = [feature_fitness(n) for n in nests]
    best_idx = fitness.index(min(fitness))
    best_nest = nests[best_idx][:]
    best_fitness = fitness[best_idx]

    for t in range(max_iter):
        for i in range(n):
            step = levy_flight(1.5, d)
            new_nest = [min(1, max(0, nests[i][j] + step[j])) for j in range(d)]
            new_fit = feature_fitness(new_nest)
            if new_fit < fitness[i]:
                nests[i] = new_nest
                fitness[i] = new_fit

        # Abandon some nests
        for i in range(n):
            if random.random() < pa:
                nests[i] = [random.random() for _ in range(d)]
                fitness[i] = feature_fitness(nests[i])

        min_idx = fitness.index(min(fitness))
        if fitness[min_idx] < best_fitness:
            best_nest = nests[min_idx][:]
            best_fitness = fitness[min_idx]

        print(f"Iteration {t+1}/{max_iter}, Best Fitness = {best_fitness:.4f}")

    return best_nest, best_fitness


best_sol, best_fit = cuckoo_search_fs()
selected_features = [i for i, v in enumerate(best_sol) if v > 0.5]
print("\nSelected Features:", selected_features)
print("Best Fitness:", best_fit)
